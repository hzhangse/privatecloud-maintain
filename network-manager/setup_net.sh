#!/bin/bash

# ==============================
# 定义全局变量
# ==============================
BASE_INTERFACE="vmbr0"
#NODES=("192.168.122.91" "192.168.122.92" ) # 集群节点 IP 地址
NODES=("193.168.122.94" "192.168.122.91")
NETWORK_MODE="vxlan"         # 可选值：vlan, vxlan
VIRTUAL_IP="192.168.122.100" # 浮动 IP 地址
DNS_NODE="192.168.122.91"

BGP_NODE="" # BGP 节点 IP 地址

#/lib/systemd/system/pvenetcommit.service 会删db.conf,要disable  systemctl disable pvenetcommit.service  systemctl status ovsdb-server.service
####vxlan相关配置参数
VXLAN_CIDRS=("172.16.40.0/24")    # VXLAN 子网 CIDR
VXLAN_MODE="p2p_ovs"              # 可选值：p2p, broadcast,p2p_ovs
VXLAN_ID=10                       # VXLAN ID
VXLAN_MULTICAST_GROUP="239.0.0.1" # VXLAN 组播地址 (用于广播模式)
VXLAN_DSTPORT=4789                # VXLAN 目标端口
VXLAN_ID_BASE=10

####vlan相关配置参数
VLAN_CIDRS=()        # VLAN 子网 CIDR
VLAN_MODE="iproute2" # 可选值：ovs, iproute2
VLAN_TAG_BASE=0
VLAN_OVS_BRIDGE="ovsbr_vlan"
VLAN_iproute2_BRIDGE="br_vlan"

# ==============================
# 加载辅助脚本
# ==============================
workdir=$(pwd)

source $workdir/config_vlan.sh
source $workdir/config_vxlan.sh
source $workdir/config_dhcp.sh
source $workdir/config_keeplive.sh
#source ./config_bgp.sh

source $(dirname "$PWD")/utils.sh

# 封装函数：建立虚机网络
configure_base_lan() {
    local NODE=$1
    local zone_gw=$2
    ssh root@$NODE "cat << 'EOF' > /etc/network/interfaces
# network interface settings; autogenerated
# Please do NOT modify this file directly, unless you know what
# you're doing.
#
# If you want to manage parts of the network configuration manually,
# please utilize the 'source' or 'source-directory' directives to do
# so.
# PVE will preserve these directives, but will NOT read its network
# configuration from sourced files, so do not attempt to move any of
# the PVE managed interfaces into external files!

auto lo
iface lo inet loopback

auto enp1s0
iface enp1s0 inet manual
	up ip link set enp1s0 up || true
	post-down ip link set enp1s0 down || true


auto $BASE_INTERFACE
iface $BASE_INTERFACE inet static
	address ${NODE}/24
	gateway ${zone_gw}
	bridge-ports enp1s0
	bridge-stp off
	bridge-fd 0
    
EOF"

}

# 封装函数：配置单个节点
configure_node() {
    local NODE=$1
    local zone_gw=$2

    if [[ $zone_gw == "" ]]; then
        zone_gw=$ZONE_GATEWAY
    fi
    # ==============================
    # 1. 安装依赖
    # ==============================
    #install_dependencies "$NODE"

    # 清空现有的 /etc/network/interfaces 文件，并初始化基本配置
    configure_base_lan "$NODE" $zone_gw

    # ==============================
    # 2. 根据 NETWORK_MODE 和 VXLAN_MODE 选择配置逻辑
    # ==============================
    if [[ "$NETWORK_MODE" == "vlan" ]]; then
        configure_vlan "$NODE" "${VLAN_CIDRS[@]}"

    elif [[ "$NETWORK_MODE" == "vxlan" ]]; then

        if [[ "$VXLAN_MODE" == "broadcast" ]]; then
            configure_vxlan_broadcast "$NODE" "${VXLAN_CIDRS[@]}"

        elif [[ "$VXLAN_MODE" == "p2p" || "$VXLAN_MODE" == "p2p_ovs" ]]; then
            VXLAN_CIDRS_STR=$(array_to_string "," "${VXLAN_CIDRS[@]}")
            ENDPOINT_NODES_STR=$(array_to_string "," "${NODES[@]}")
            configure_vxlan_p2p "$NODE" "$ENDPOINT_NODES_STR" "$VXLAN_CIDRS_STR" $size

        fi

    elif [[ "$NETWORK_MODE" == "vlan-vxlan" ]]; then
        configure_vlan "$NODE" "${VLAN_CIDRS[@]}"
        # 检查条件并配置 VXLAN P2P
        if [[ "$VXLAN_TUNPOINT" == "$NODE" && ${#VXLAN_ENDPOINTS[@]} -gt 0 &&
            ("$VXLAN_MODE" == "p2p" || "$VXLAN_MODE" == "p2p_ovs") ]]; then

            VXLAN_CIDRS_STR=$(array_to_string "," "${VXLAN_CIDRS[@]}")
            ENDPOINT_NODES_STR=$(array_to_string "," "${VXLAN_ENDPOINTS[@]}")

            # 打印调试信息
            echo "Configuring VXLAN P2P for VXLAN_TUNPOINT: $VXLAN_TUNPOINT"
            echo "Endpoints: $ENDPOINT_NODES_STR"
            echo "CIDRs: $VXLAN_CIDRS_STR"

            # 调用配置函数
            configure_vxlan_p2p "$VXLAN_TUNPOINT" "$ENDPOINT_NODES_STR" "$VXLAN_CIDRS_STR"
        fi

    fi

    # ==============================
    # 3. 配置 DHCP Failover
    # ==============================
    if [[ "$NODE" == "$DNS_NODE" ]]; then
        configure_dhcp_failover "$NODE"
    fi

    # ==============================
    # 4. 配置 BGP
    # ==============================
    # if [[ "$NODE" == "$BGP_NODE" ]]; then
    #     configure_bgp "$NODE"
    # fi
    # ==============================
    # 5. 配置 Keepalived
    # ==============================

    #configure_keepalived "$NODE" "$VIRTUAL_IP" "$BASE_INTERFACE"
    # ==============================
    # 5. 重启网络服务以应用所有更改
    # ==============================
    ssh root@$NODE "systemctl daemon-reload && systemctl restart networking.service && systemctl restart openvswitch-switch "
}

configure_zone() {
    # 定义 JSON 文件路径
    JSON_FILE=$1

    # 检查 jq 是否已安装
    if ! command -v jq &>/dev/null; then
        echo "Error: jq is not installed. Please install jq first."
        exit 1
    fi

    # 检查 JSON 文件是否存在
    if [[ ! -f "$JSON_FILE" ]]; then
        echo "Error: JSON file '$JSON_FILE' not found."
        exit 1
    fi
    # 初始化空数组
    zones=()

    # 使用 while read 循环读取每一行
    while IFS= read -r line; do
        zones+=("$line")
    done < <(jq -c '.zones[]' "$JSON_FILE")

    # 打印数组内容
    for zone in "${zones[@]}"; do
        echo "$zone"

        # 开始解析# 初始化计数器
        size=1
        parse_json_recursive "$zone" ""
        echo "配置zone:${ZONE_NAME}开始"

        NODES=("${NODES_IP[@]}")
        for NODE in "${NODES_IP[@]}"; do
            echo "正在配置节点 $NODE..."
            configure_node "$NODE" ${NODES_GATEWAY[((size - 1))]}
            ((size++))

        done

        echo "zone:${ZONE_NAME}'s所有节点的配置已完成！"
        echo "配置zone:${ZONE_NAME}结束"
    done

}

configure_zone "$workdir/zones.json"
